Maximum subarray problem
========================

From Wikipedia, the free encyclopedia

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Maximum_Subarray_Visualization.svg/220px-Maximum_Subarray_Visualization.svg.png)](https://en.wikipedia.org/wiki/File:Maximum_Subarray_Visualization.svg)

Visualization of how sub-arrays change based on start and end positions of a sample. Each possible contiguous sub-array is represented by a point on a colored line. That point's y-coordinate represents the sum of the sample. Its x-coordinate represents the end of the sample, and the leftmost point on that colored line represents the start of the sample. In this case, the array from which samples are taken is \[2, 3, -1, -20, 5, 10\].

In [computer science](https://en.wikipedia.org/wiki/Computer_science "Computer science"), the **maximum sum subarray problem**, also known as the **maximum segment sum problem**, is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional [array](https://en.wikipedia.org/wiki/Array_data_structure "Array data structure") A\[1...n\] of numbers. It can be solved in ![{\displaystyle O(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a) time and ![{\displaystyle O(1)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21) space.

Formally, the task is to find indices ![{\displaystyle i}](https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20) and ![{\displaystyle j}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0) with ![{\displaystyle 1\leq i\leq j\leq n}](https://wikimedia.org/api/rest_v1/media/math/render/svg/95763b48b784f1cd453a4dc4a2c2f39e22997a43), such that the sum

![{\displaystyle \sum _{x=i}^{j}A[x]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3f4ae4590a685044ab6ba7cc8b23cc7c57f5689e)

is as large as possible. (Some formulations of the problem also allow the empty subarray to be considered; by convention, [the sum of all values of the empty subarray](https://en.wikipedia.org/wiki/Empty_sum "Empty sum") is zero.) Each number in the input array A could be positive, negative, or zero.[\[1\]](#cite_note-FOOTNOTEBentley198969-1)

For example, for the array of values \[−2, 1, −3, 4, −1, 2, 1, −5, 4\], the contiguous subarray with the largest sum is \[4, −1, 2, 1\], with sum 6.

Some properties of this problem are:

1.  If the array contains all non-negative numbers, then the problem is trivial; a maximum subarray is the entire array.
2.  If the array contains all non-positive numbers, then a solution is any subarray of size 1 containing the maximal value of the array (or the empty subarray, if it is permitted).
3.  Several different sub-arrays may have the same maximum sum.

Although this problem can be solved using several different algorithmic techniques, including brute force,[\[2\]](#cite_note-FOOTNOTEBentley198970-2) divide and conquer,[\[3\]](#cite_note-FOOTNOTEBentley198973-3) dynamic programming,[\[4\]](#cite_note-FOOTNOTEBentley198974-4) and reduction to shortest paths, a simple single-pass algorithm known as Kadane's algorithm solves it efficiently.

The maximum subarray problem was proposed by [Ulf Grenander](https://en.wikipedia.org/wiki/Ulf_Grenander "Ulf Grenander") in 1977 as a simplified model for [maximum likelihood estimation](https://en.wikipedia.org/wiki/Maximum_likelihood_estimation "Maximum likelihood estimation") of patterns in digitized images.[\[5\]](#cite_note-FOOTNOTEBentley1984868-869-5)

Grenander was looking to find a rectangular subarray with maximum sum, in a two-dimensional array of real numbers. A brute-force algorithm for the two-dimensional problem runs in _O_(_n_6) time; because this was prohibitively slow, Grenander proposed the one-dimensional problem to gain insight into its structure. Grenander derived an algorithm that solves the one-dimensional problem in _O_(_n_2) time,[\[note 1\]](#cite_note-6) improving the brute force running time of _O_(_n_3). When [Michael Shamos](https://en.wikipedia.org/wiki/Michael_Shamos "Michael Shamos") heard about the problem, he overnight devised an _O_(_n_ log _n_) [divide-and-conquer algorithm](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm "Divide-and-conquer algorithm") for it. Soon after, Shamos described the one-dimensional problem and its history at a [Carnegie Mellon University](https://en.wikipedia.org/wiki/Carnegie_Mellon_University "Carnegie Mellon University") seminar attended by [Jay Kadane](https://en.wikipedia.org/wiki/Jay_Kadane "Jay Kadane"), who designed within a minute an _O_(_n_)-time algorithm,[\[5\]](#cite_note-FOOTNOTEBentley1984868-869-5)[\[6\]](#cite_note-FOOTNOTEBentley198976-77-7)[\[7\]](#cite_note-FOOTNOTEGries1982211-8) which is as fast as possible.[\[note 2\]](#cite_note-9) In 1982, [David Gries](https://en.wikipedia.org/wiki/David_Gries "David Gries") obtained the same _O_(_n_)-time algorithm by applying [Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra "Edsger W. Dijkstra")'s "standard strategy";[\[8\]](#cite_note-FOOTNOTEGries1982209-211-10) in 1989, [Richard Bird](https://en.wikipedia.org/wiki/Richard_Bird_(computer_scientist) "Richard Bird (computer scientist)") derived it by purely algebraic manipulation of the brute-force algorithm using the [Bird–Meertens formalism](https://en.wikipedia.org/wiki/Bird%E2%80%93Meertens_formalism "Bird–Meertens formalism").[\[9\]](#cite_note-FOOTNOTEBird1989Sect.8,_p.126-11)

Grenander's two-dimensional generalization can be solved in O(_n_3) time either by using Kadane's algorithm as a subroutine, or through a divide-and-conquer approach. Slightly faster algorithms based on [distance matrix multiplication](https://en.wikipedia.org/wiki/Min-plus_matrix_multiplication "Min-plus matrix multiplication") have been proposed by [Tamaki & Tokuyama (1998)](#CITEREFTamakiTokuyama1998) and by [Takaoka (2002)](#CITEREFTakaoka2002). There is some evidence that no significantly faster algorithm exists; an algorithm that solves the two-dimensional maximum subarray problem in O(_n_3−ε) time, for any ε>0, would imply a similarly fast algorithm for the [all-pairs shortest paths](https://en.wikipedia.org/wiki/Shortest_path_problem#All-pairs_shortest_paths "Shortest path problem") problem.[\[10\]](#cite_note-FOOTNOTEBackursDikkalaTzamos2016-12)

Maximum subarray problems arise in many fields, such as genomic [sequence analysis](https://en.wikipedia.org/wiki/Sequence_analysis "Sequence analysis") and [computer vision](https://en.wikipedia.org/wiki/Computer_vision "Computer vision").

Genomic sequence analysis employs maximum subarray algorithms to identify important biological segments of protein sequences that have unusual properties, by assigning scores to points within the sequence that are positive when a motif to be recognized is present, and negative when it is not, and then seeking the maximum subarray among these scores. These problems include conserved segments, GC-rich regions, tandem repeats, low-complexity filter, DNA binding domains, and regions of high charge.[\[11\]](#cite_note-13)

In [computer vision](https://en.wikipedia.org/wiki/Computer_vision "Computer vision"), bitmap images generally consist only of positive values, for which the maximum subarray problem is trivial: the result is always the whole array. However, after subtracting a threshold value (such as the average pixel value) from each pixel, so that above-average pixels will be positive and below-average pixels will be negative, the maximum subarray problem can be applied to the modified image to detect bright areas within it.[\[12\]](#cite_note-14)

### No empty subarrays admitted

\[[edit](https://en.wikipedia.org/w/index.php?title=Maximum_subarray_problem&action=edit&section=4 "Edit section: No empty subarrays admitted")\]

[Kadane's](https://en.wikipedia.org/wiki/Joseph_Born_Kadane "Joseph Born Kadane") algorithm scans the given array ![{\displaystyle A[1\ldots n]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e3d1923568ccfdc916c6cd1c84cb282a32af9074) from left to right. In the ![{\displaystyle j}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0)th step, it computes the subarray with the largest sum ending at ![{\displaystyle j}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0); this sum is maintained in variable `current_sum`.[\[note 3\]](#cite_note-15) Moreover, it computes the subarray with the largest sum anywhere in ![{\displaystyle A[1\ldots j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f81bf04402d996fbf9efe4c9e68c68d804022adf), maintained in variable `best_sum`,[\[note 4\]](#cite_note-16) and easily obtained as the maximum of all values of `current_sum` seen so far, cf. line 7 of the algorithm.

As a [loop invariant](https://en.wikipedia.org/wiki/Loop_invariant "Loop invariant"), in the ![{\displaystyle j}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0)th step, the old value of `current_sum` holds the maximum over all ![{\displaystyle i\in \{1,\ldots ,j-1\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/98fd84c4688669f1ab56401080bd566b4be35ba6) of the sum ![{\displaystyle A[i]+\cdots +A[j-1]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3d953b5c43fc85b567297a449586a6aa761a6c83). Therefore, `current_sum`![{\displaystyle +A[j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f276f74cd74ae67e23c51b1e9ef3764c5798adfd)[\[note 5\]](#cite_note-17) is the maximum over all ![{\displaystyle i\in \{1,\ldots ,j-1\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/98fd84c4688669f1ab56401080bd566b4be35ba6) of the sum ![{\displaystyle A[i]+\cdots +A[j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ce9a7a1d7259eb0056fc37f9bed9219049cb8cde). To extend the latter maximum to cover also the case ![{\displaystyle i=j}](https://wikimedia.org/api/rest_v1/media/math/render/svg/706e0928b2bf0f24076b0c90bb20616ff2068343), it is sufficient to consider also the singleton subarray ![{\displaystyle A[j\;\ldots \;j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/551bbbcd4e8a7a11d988f828dc1c574b73d32c59). This is done in line 6 by assigning ![{\displaystyle \max(A[j],}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a855fb0a19d2d6af178dffdd6b9160523d0f4647)`current_sum`![{\displaystyle +A[j])}](https://wikimedia.org/api/rest_v1/media/math/render/svg/188c430a18abd0a38d9b527d13d3abd631d0d51e) as the new value of `current_sum`, which after that holds the maximum over all ![{\displaystyle i\in \{1,\ldots ,j\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f8304cdc726f60e272d99f7c4f36a6ab651370d9) of the sum ![{\displaystyle A[i]+\cdots +A[j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ce9a7a1d7259eb0056fc37f9bed9219049cb8cde).

Thus, the problem can be solved with the following code,[\[13\]](#cite_note-FOOTNOTEBentley198978,171-18) expressed in [Python](https://en.wikipedia.org/wiki/Python_(programming_language) "Python (programming language)").

def max\_subarray(numbers):
    """Find the largest sum of any contiguous subarray."""
    best\_sum \= float('-inf')
    current\_sum \= 0
    for x in numbers:
        current\_sum \= max(x, current\_sum + x)
        best\_sum \= max(best\_sum, current\_sum)
    return best\_sum

If the input contains no positive element, the returned value is that of the largest element (i.e., the value closest to 0), or negative infinity if the input was empty. For correctness, an exception should be raised when the input array is empty, since an empty array has no maximum nonempty subarray. If the array is nonempty, its first element could be used in place of negative infinity, if needed to avoid mixing numeric and non-numeric values.

The algorithm can be adapted to the case which allows empty subarrays or to keep track of the starting and ending indices of the maximum subarray.

This algorithm calculates the maximum subarray ending at each position from the maximum subarray ending at the previous position, so it can be viewed as a trivial case of [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming "Dynamic programming").

### Empty subarrays admitted

\[[edit](https://en.wikipedia.org/w/index.php?title=Maximum_subarray_problem&action=edit&section=5 "Edit section: Empty subarrays admitted")\]

Example run

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Kadane_run_%E2%88%922%2C1%2C%E2%88%923%2C4%2C%E2%88%921%2C2%2C1%2C%E2%88%925%2C4.gif/500px-Kadane_run_%E2%88%922%2C1%2C%E2%88%923%2C4%2C%E2%88%921%2C2%2C1%2C%E2%88%925%2C4.gif)](https://en.wikipedia.org/wiki/File:Kadane_run_%E2%88%922,1,%E2%88%923,4,%E2%88%921,2,1,%E2%88%925,4.gif)

Execution of Kadane's algorithm on the [above](#top) example array. _Blue:_ subarray with largest sum ending at _i_; _green:_ subarray with largest sum encountered so far; a lower case letter indicates an empty array; variable _i_ is left implicit in Python code.

Kadane's original algorithm solves the problem variant when empty subarrays are admitted.[\[4\]](#cite_note-FOOTNOTEBentley198974-4)[\[7\]](#cite_note-FOOTNOTEGries1982211-8) This variant will return 0 if the input contains no positive elements (including when the input is empty). It is obtained by two changes in code: in line 3, `best_sum` should be initialized to 0 to account for the empty subarray ![{\displaystyle A[0\ldots -1]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/82f6afaff54a6e361dfa24af514883b91fe5967f)

and line 6 in the for loop `current_sum` should be updated as `max(0, current_sum + x)`.[\[note 6\]](#cite_note-19)

        current\_sum \= max(0, current\_sum + x)

As a [loop invariant](https://en.wikipedia.org/wiki/Loop_invariant "Loop invariant"), in the ![{\displaystyle j}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2f461e54f5c093e92a55547b9764291390f0b5d0)th step, the old value of `current_sum` holds the maximum over all ![{\displaystyle i\in \{1,\ldots ,j\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f8304cdc726f60e272d99f7c4f36a6ab651370d9) of the sum ![{\displaystyle A[i]+\cdots +A[j-1]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3d953b5c43fc85b567297a449586a6aa761a6c83).[\[note 7\]](#cite_note-20) Therefore, `current_sum`![{\displaystyle +A[j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f276f74cd74ae67e23c51b1e9ef3764c5798adfd) is the maximum over all ![{\displaystyle i\in \{1,\ldots ,j\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f8304cdc726f60e272d99f7c4f36a6ab651370d9) of the sum ![{\displaystyle A[i]+\cdots +A[j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ce9a7a1d7259eb0056fc37f9bed9219049cb8cde). To extend the latter maximum to cover also the case ![{\displaystyle i=j+1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c929824b3149ba99292d6c5e04e9e22262c78295), it is sufficient to consider also the empty subarray ![{\displaystyle A[j+1\;\ldots \;j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4e7cbec3c9700cbffc27f7452cc996629800229e). This is done in line 6 by assigning ![{\displaystyle \max(0,}](https://wikimedia.org/api/rest_v1/media/math/render/svg/90441ccc647a71d730f3b2c3db44e04784fbe6e9)`current_sum`![{\displaystyle +A[j])}](https://wikimedia.org/api/rest_v1/media/math/render/svg/188c430a18abd0a38d9b527d13d3abd631d0d51e) as the new value of `current_sum`, which after that holds the maximum over all ![{\displaystyle i\in \{1,\ldots ,j+1\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6d13ec7bc1287e6f265cff33a15a440c57c92bb5) of the sum ![{\displaystyle A[i]+\cdots +A[j]}](https://wikimedia.org/api/rest_v1/media/math/render/svg/ce9a7a1d7259eb0056fc37f9bed9219049cb8cde). Machine-verified [C](https://en.wikipedia.org/wiki/C_(programming_language) "C (programming language)") / [Frama-C](https://en.wikipedia.org/wiki/Frama-C "Frama-C") code of both variants can be found [here](https://commons.wikimedia.org/wiki/File:Kadane_run_%E2%88%922,1,%E2%88%923,4,%E2%88%921,2,1,%E2%88%925,4.gif#Source_code "commons:File:Kadane run −2,1,−3,4,−1,2,1,−5,4.gif").

### Computing the best subarray's position

\[[edit](https://en.wikipedia.org/w/index.php?title=Maximum_subarray_problem&action=edit&section=6 "Edit section: Computing the best subarray's position")\]

The algorithm can be modified to keep track of the starting and ending indices of the maximum subarray as well.

Because of the way this algorithm uses optimal substructures (the maximum subarray ending at each position is calculated in a simple way from a related but smaller and overlapping subproblem: the maximum subarray ending at the previous position) this algorithm can be viewed as a simple/trivial example of [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming "Dynamic programming").

The runtime complexity of Kadane's algorithm is ![{\displaystyle O(n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a) and its space complexity is ![{\displaystyle O(1)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21).[\[4\]](#cite_note-FOOTNOTEBentley198974-4)[\[7\]](#cite_note-FOOTNOTEGries1982211-8)

Similar problems may be posed for higher-dimensional arrays, but their solutions are more complicated; see, e.g., [Takaoka (2002)](#CITEREFTakaoka2002). [Brodal & Jørgensen (2007)](#CITEREFBrodalJørgensen2007) showed how to find the _k_ largest subarray sums in a one-dimensional array, in the optimal time bound ![{\displaystyle O(n+k)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cebd2e4442e56daa59f3fab79339f952122c29e8).

The Maximum sum _k_\-disjoint subarrays can also be computed in the optimal time bound ![{\displaystyle O(n+k)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/cebd2e4442e56daa59f3fab79339f952122c29e8) .[\[14\]](#cite_note-FOOTNOTEBengtssonChen2007-21)

*   [Subset sum problem](https://en.wikipedia.org/wiki/Subset_sum_problem "Subset sum problem")

1.  **[^](#cite_ref-FOOTNOTEBentley198969_1-0 "Jump up")** [Bentley 1989](#CITEREFBentley1989), p. 69.
2.  **[^](#cite_ref-FOOTNOTEBentley198970_2-0 "Jump up")** [Bentley 1989](#CITEREFBentley1989), p. 70.
3.  **[^](#cite_ref-FOOTNOTEBentley198973_3-0 "Jump up")** [Bentley 1989](#CITEREFBentley1989), p. 73.
4.  ^ [Jump up to: _**a**_](#cite_ref-FOOTNOTEBentley198974_4-0) [_**b**_](#cite_ref-FOOTNOTEBentley198974_4-1) [_**c**_](#cite_ref-FOOTNOTEBentley198974_4-2) [Bentley 1989](#CITEREFBentley1989), p. 74.
5.  ^ [Jump up to: _**a**_](#cite_ref-FOOTNOTEBentley1984868-869_5-0) [_**b**_](#cite_ref-FOOTNOTEBentley1984868-869_5-1) [Bentley 1984](#CITEREFBentley1984), p. 868-869.
6.  **[^](#cite_ref-FOOTNOTEBentley198976-77_7-0 "Jump up")** [Bentley 1989](#CITEREFBentley1989), p. 76-77.
7.  ^ [Jump up to: _**a**_](#cite_ref-FOOTNOTEGries1982211_8-0) [_**b**_](#cite_ref-FOOTNOTEGries1982211_8-1) [_**c**_](#cite_ref-FOOTNOTEGries1982211_8-2) [Gries 1982](#CITEREFGries1982), p. 211.
8.  **[^](#cite_ref-FOOTNOTEGries1982209-211_10-0 "Jump up")** [Gries 1982](#CITEREFGries1982), p. 209-211.
9.  **[^](#cite_ref-FOOTNOTEBird1989Sect.8,_p.126_11-0 "Jump up")** [Bird 1989](#CITEREFBird1989), Sect.8, p.126.
10.  **[^](#cite_ref-FOOTNOTEBackursDikkalaTzamos2016_12-0 "Jump up")** [Backurs, Dikkala & Tzamos 2016](#CITEREFBackursDikkalaTzamos2016).
11.  **[^](#cite_ref-13 "Jump up")** [Ruzzo & Tompa (1999)](#CITEREFRuzzoTompa1999); [Alves, Cáceres & Song (2004)](#CITEREFAlvesCáceresSong2004)
12.  **[^](#cite_ref-14 "Jump up")** [Bae & Takaoka (2006)](#CITEREFBaeTakaoka2006); [Weddell et al. (2013)](#CITEREFWeddellReadThaherTakaoka2013)
13.  **[^](#cite_ref-FOOTNOTEBentley198978,171_18-0 "Jump up")** [Bentley 1989](#CITEREFBentley1989), p. 78,171. Bentley, like Gries, first introduces the variant admitting empty subarrays, see [below](#Empty_subarrays_admitted), and describes only the changes.
14.  **[^](#cite_ref-FOOTNOTEBengtssonChen2007_21-0 "Jump up")** [Bengtsson & Chen 2007](#CITEREFBengtssonChen2007).

*   Alves, Carlos E. R.; Cáceres, Edson; Song, Siang W. (2004), "BSP/CGM Algorithms for Maximum Subsequence and Maximum Subarray", in Kranzlmüller, Dieter; Kacsuk, Péter; Dongarra, Jack J. (eds.), _Recent Advances in Parallel Virtual Machine and Message Passing Interface, 11th European PVM/MPI Users' Group Meeting, Budapest, Hungary, September 19-22, 2004, Proceedings_, Lecture Notes in Computer Science, vol. 3241, Springer, pp. 139–146, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/978-3-540-30218-6\_24](https://doi.org/10.1007%2F978-3-540-30218-6_24), [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-3-540-23163-9](https://en.wikipedia.org/wiki/Special:BookSources/978-3-540-23163-9 "Special:BookSources/978-3-540-23163-9")
*   Backurs, Arturs; Dikkala, Nishanth; Tzamos, Christos (2016), "Tight Hardness Results for Maximum Weight Rectangles", _Proc. 43rd International Colloquium on Automata, Languages, and Programming_: 81:1–81:13, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.4230/LIPIcs.ICALP.2016.81](https://doi.org/10.4230%2FLIPIcs.ICALP.2016.81), [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [12720136](https://api.semanticscholar.org/CorpusID:12720136)
*   Bae, Sung Eun (2007), [_Sequential and Parallel Algorithms for the Generalized Maximum Subarray Problem_](https://web.archive.org/web/20171026110814/https://pdfs.semanticscholar.org/bea4/1795adaf240b9db4195b9dc511bd8d46bff1.pdf) (PDF) (Ph.D. thesis), University of Canterbury, [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [2681670](https://api.semanticscholar.org/CorpusID:2681670), archived from [the original](https://pdfs.semanticscholar.org/bea4/1795adaf240b9db4195b9dc511bd8d46bff1.pdf) (PDF) on 2017-10-26.
*   Bae, Sung Eun; Takaoka, Tadao (2006), "Improved Algorithms for the \\emph{K}-Maximum Subarray Problem", _The Computer Journal_, **49** (3): 358–374, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1093/COMJNL/BXL007](https://doi.org/10.1093%2FCOMJNL%2FBXL007)
*   Bengtsson, Fredrik; Chen, Jingsen (2007), [_Computing maximum-scoring segments optimally_](http://ltu.diva-portal.org/smash/get/diva2:995901/FULLTEXT01.pdf) (PDF) (Research report), Luleå University of Technology
*   [Bentley, Jon](https://en.wikipedia.org/wiki/Jon_Bentley_(computer_scientist) "Jon Bentley (computer scientist)") (1984), "Programming Pearls: Algorithm Design Techniques", _[Communications of the ACM](https://en.wikipedia.org/wiki/Communications_of_the_ACM "Communications of the ACM")_, **27** (9): 865–873, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1145/358234.381162](https://doi.org/10.1145%2F358234.381162), [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [207565329](https://api.semanticscholar.org/CorpusID:207565329)
*   Bentley, Jon (May 1989), [_Programming Pearls_](https://archive.org/details/programmingpearl00bent) (2nd? ed.), Reading, MA: Addison Wesley, [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [0-201-10331-1](https://en.wikipedia.org/wiki/Special:BookSources/0-201-10331-1 "Special:BookSources/0-201-10331-1")
*   [Bird, Richard S.](https://en.wikipedia.org/wiki/Richard_S._Bird "Richard S. Bird") (1989), "Algebraic Identities for Program Calculation", _[The Computer Journal](https://en.wikipedia.org/wiki/The_Computer_Journal "The Computer Journal")_, **32** (2): 122–126, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1093/comjnl/32.2.122](https://doi.org/10.1093%2Fcomjnl%2F32.2.122)
*   Brodal, Gerth Stølting; Jørgensen, Allan Grønlund (2007), "A linear time algorithm for the _k_ maximal sums problem", _Mathematical Foundations of Computer Science 2007_, Lecture Notes in Computer Science, vol. 4708, Springer-Verlag, pp. 442–453, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/978-3-540-74456-6\_40](https://doi.org/10.1007%2F978-3-540-74456-6_40), [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-3-540-74455-9](https://en.wikipedia.org/wiki/Special:BookSources/978-3-540-74455-9 "Special:BookSources/978-3-540-74455-9").
*   Gries, David (1982), ["A Note on the Standard Strategy for Developing Loop Invariants and Loops"](https://core.ac.uk/download/pdf/82596333.pdf) (PDF), _Science of Computer Programming_, **2** (3): 207–241, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/0167-6423(83)90015-1](https://doi.org/10.1016%2F0167-6423%2883%2990015-1), [hdl](https://en.wikipedia.org/wiki/Hdl_(identifier) "Hdl (identifier)"):[1813/6370](https://hdl.handle.net/1813%2F6370)
*   Ruzzo, Walter L.; Tompa, Martin (1999), ["A Linear Time Algorithm for Finding All Maximal Scoring Subsequences"](https://www.aaai.org/Library/ISMB/1999/ismb99-027.php), in Lengauer, Thomas; Schneider, Reinhard; Bork, Peer; Brutlag, Douglas L.; Glasgow, Janice I.; Mewes, Hans-Werner; Zimmer, Ralf (eds.), _Proceedings of the Seventh International Conference on Intelligent Systems for Molecular Biology, August 6–10, 1999, Heidelberg, Germany_, AAAI, pp. 234–241
*   Takaoka, Tadao (2002), "Efficient algorithms for the maximum subarray problem by distance matrix multiplication", _Electronic Notes in Theoretical Computer Science_, **61**: 191–200, [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/S1571-0661(04)00313-5](https://doi.org/10.1016%2FS1571-0661%2804%2900313-5).
*   Tamaki, Hisao; Tokuyama, Takeshi (1998), ["Algorithms for the Maximum Subarray Problem Based on Matrix Multiplication"](http://dl.acm.org/citation.cfm?id=314613.314823), _Proceedings of the 9th Symposium on Discrete Algorithms (SODA)_: 446–452, [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-0-89871-410-4](https://en.wikipedia.org/wiki/Special:BookSources/978-0-89871-410-4 "Special:BookSources/978-0-89871-410-4"), retrieved November 17, 2018
*   Weddell, Stephen John; Read, Tristan; Thaher, Mohammed; Takaoka, Tadao (2013), "Maximum subarray algorithms for use in astronomical imaging", _Journal of Electronic Imaging_, **22** (4): 043011, [Bibcode](https://en.wikipedia.org/wiki/Bibcode_(identifier) "Bibcode (identifier)"):[2013JEI....22d3011W](https://ui.adsabs.harvard.edu/abs/2013JEI....22d3011W), [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1117/1.JEI.22.4.043011](https://doi.org/10.1117%2F1.JEI.22.4.043011)

*   TAN, Lirong. ["Maximum Contiguous Subarray Sum Problems"](https://web.archive.org/web/20151010072051/http://www.picb.ac.cn/~xiaohang/vimwiki/study/tanlirong/Algorithm/project/Report.pdf) (PDF). Archived from [the original](http://www.picb.ac.cn/~xiaohang/vimwiki/study/tanlirong/Algorithm/project/Report.pdf) (PDF) on 2015-10-10. Retrieved 2017-10-26.
*   Mu, Shin-Cheng (2010). ["The Maximum Segment Sum Problem: Its Origin, and a Derivation"](https://www.iis.sinica.edu.tw/~scm/2010/maximum-segment-sum-origin-and-derivation).
*   ["Notes on Maximum Subarray Problem"](http://cs.slu.edu/~goldwamh/courses/slu/csci314/2012_Fall/lectures/maxsubarray/). 2012.
*   [www.algorithmist.com](http://www.algorithmist.com/index.php/Kadane's_Algorithm)
*   [alexeigor.wikidot.com](http://alexeigor.wikidot.com/kadane)
*   [greatest subsequential sum problem on Rosetta Code](http://rosettacode.org/wiki/Greatest_subsequential_sum)
*   [geeksforgeeks page on Kadane's Algorithm](https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/)